# v0.3.0 Plan — Blocklist Subscriptions

Purpose: deliver first-class blocklist support (local files + remote feeds) with resolver integration and periodic updates.

## Goals (scope)
- Block decisions integrated into resolver (non-authoritative path) with default REFUSED policy
- Ingest multiple list formats (plain FQDN, hosts-file style)
- Load from disk paths and fetch from HTTP(S) feeds
- Periodic updates for both local files (re-read) and remote feeds (re-fetch)
- Efficient in-memory matching for exact domains and subdomains

Non-goals (v0.3):
- Adblock/uBlock filter syntax, regex rules, category policies, UI/API
- active HTTP/S ports to accept and close traffic a-la pihole

## High-level deliverables
- Domain types for block rules/decisions
- Blocklist repository implementation (parsers + storage + stats)
- Feed ingestion (file + HTTP) with periodic updater
- Resolver integration and config wiring
- Tests and basic docs

## Architecture touchpoints
- Domain: new value types for BlockRule and BlockDecision (pure, no deps)
- Repos: implement Blocklist repo (replace nop) with parsers and in-memory store
- Gateways: HTTP fetcher for remote feeds (stateless client)
- Services: resolver consults blocklist for non-authoritative queries
- Config: DNS_ envs enabling blocklists, sources, and update interval

## Minimal domain model
- BlockRule
	- name: string (canonical FQDN, no trailing dot; e.g., "example.com")
	- kind: enum { exact, suffix }  // suffix matches subdomains
	- source: string                 // feed or file identifier
	- addedAt: time.Time             // when ingested
	- reason: string (optional)

- BlockDecision
	- blocked: bool
	- matchedRule: string  // rule name
	- source: string

## Interfaces (sketch)
- Blocklist (service-facing)
	- IsBlocked(domain string) (bool, BlockDecision)
	- Update(ctx context.Context) error
	- Stats() BlockStats

- FeedSource
	- Fetch(ctx, uri string) (io.ReadCloser, etag string, lastModified string, err error)

- Parser
	- Parse(r io.Reader) ([]BlockRule, error) // supports plain list + hosts

## Storage design (v0.3) — Bloom + Bolt

Rationale: Keep fast negatives in memory (Bloom filters) while storing canonical truth in a lightweight embedded KV (BoltDB). Adds transparent LRU decision cache for repeated queries. Prioritizes predictable latency, low RAM, and simple, robust on-disk format.

- Normalization for all paths: lowercase, strip trailing dot, trim whitespace
- In-memory structures
	- BloomExact: Bloom filter of exact domain rules
	- BloomSuffix: Bloom filter of suffix rules (rule roots only)
	- Decision LRU: key=domain string, value=BlockDecision (size configurable)
- On-disk (BoltDB)
	- Bucket `exact`: key = canonical domain (e.g., "example.com"), value = 1 byte
	- Bucket `suffix`: key = reversed-domain root with trailing dot (e.g., "com.example."), value = 1 byte
	- Optional Bucket `meta`: counts, version, updatedAt, source digests
- Query path
	1) Normalize domain; check Decision LRU → return on hit
	2) If BloomExact says possible → Bolt exact lookup
	3) For suffix: iterate candidate suffixes from most specific to TLD
		 - For each suffix, BloomSuffix says possible? If yes, check Bolt by prefix in `suffix` using reversed-domain cursor seek
	4) Cache final decision in LRU
- Update path (RCU-style swap)
	- Fetch+parse all sources → build new exact/suffix sets
	- Rebuild Bloom filters sized for N and FP rate p
	- Write to Bolt in a new top-level version (e.g., `vNNN` buckets) or a temp file then atomic rename
	- Swap active version pointer and replace Bloom filters; clear Decision LRU
	- Keep readers uninterrupted: use versioned buckets to avoid file descriptor swap
- Sizing and targets
	- Bloom FP default p=1% (configurable); size M ≈ -(N ln p)/(ln 2)^2
	- Limit suffix probes per query with a depth cap (e.g., <= 10 labels)
	- Goal: p50 lookup < 50µs with warm LRU; negatives should avoid most Bolt hits
- Concurrency
	- Resolver uses read-only Bolt transactions; updater uses a single write transaction
	- Versioned buckets allow readers during updates; finalize by toggling `meta.activeVersion`
	- Periodic full rebuild compacts Bolt implicitly

## Resolver integration
- Apply blocklist only when no authoritative zone match
- On block: respond REFUSED by default (policy block)
- User-selectable behavior: REFUSED | NXDOMAIN | sinkhole (A/AAAA)
- Include EDNS(0) Extended DNS Error with reason "blocked" when client supports EDNS

## Configuration (new)
- DNS_BLOCKLIST_ENABLED: bool (default: false)
- DNS_BLOCKLIST_SOURCES: list (files or URLs; space/comma-separated)
- DNS_BLOCKLIST_UPDATE_INTERVAL: duration string (e.g., "6h"; default: 24h)
- DNS_BLOCKLIST_MODE: enum { refused, nxdomain, sinkhole } (default: refused)
// Sinkhole-specific (used only when MODE=sinkhole)
- DNS_BLOCKLIST_SINKHOLE_A: IPv4 (default: 0.0.0.0)
- DNS_BLOCKLIST_SINKHOLE_AAAA: IPv6 (default: ::)
- DNS_BLOCKLIST_SINKHOLE_TTL: duration or seconds (default: 60s)
// Storage-specific
- DNS_BLOCKLIST_DB_PATH: string (default: "/var/lib/rr-dns/blocklist.db"; in Docker, mount a volume like /data)
- DNS_BLOCKLIST_BLOOM_FP: float (false-positive rate; default: 0.01)
- DNS_BLOCKLIST_LRU_SIZE: int (decision cache size; default: 100000)
- DNS_BLOCKLIST_SUFFIX_DEPTH_LIMIT: int (max labels checked for suffix; default: 10)

## Tasks (issues and sub-issues)

Parent 1: [#18](https://github.com/haukened/rr-dns/issues/18) Blocklist Core (foundation)
1) [ ] [#23](https://github.com/haukened/rr-dns/issues/23) Domain types `BlockRule`, `BlockDecision` (internal/dns/domain)
	- [ ] Types defined with fields per spec; pure domain (no external deps)
	- [ ] Unit tests
2) [ ] [#24](https://github.com/haukened/rr-dns/issues/24) Config: DNS_BLOCKLIST_* vars, validation, and wiring
	- [ ] Env parsing with defaults; invalid values rejected with clear errors
	- [ ] Config README/README env table updated
	- [ ] Unit tests for parsing/validation
3) [ ] [#25](https://github.com/haukened/rr-dns/issues/25) Normalization: IDNA/punycode and Unicode dot mapping (reuse utils)
	- [ ] Helper that lowercases, strips trailing dot, maps Unicode dots, IDNA to ASCII (Update CanonicalDNSName?)
	- [ ] Tests: unicode, mixed-case, trailing dot, whitespace
4) [ ] [#26](https://github.com/haukened/rr-dns/issues/26) Optional public-suffix guard and validation
	- [ ] Toggle to reject pure TLD/public-suffix entries; error reporting and tests
5) [ ] [#27](https://github.com/haukened/rr-dns/issues/27) Parser: plain list (one FQDN per line; '#' comments)
	- [ ] Accept comments/blank lines; whitespace-trim; normalize; dedupe
	- [ ] Tests: happy/edge/error cases
6) [ ] [#28](https://github.com/haukened/rr-dns/issues/28) Parser: hosts-file (ignore IP; extract hostnames)
	- [ ] Skip comments/localhost/broadcast; handle multiple names per line
	- [ ] Tests: IPv4/IPv6 lines, comments, duplicates
7) [ ] [#29](https://github.com/haukened/rr-dns/issues/29) Parser: accept leading "*."/"." wildcard forms (map to suffix)
	- [ ] Normalize to suffix rule with apex-inclusive semantics; tests

Parent 2: [#19](https://github.com/haukened/rr-dns/issues/19) Storage and Matcher (Bloom + Bolt + LRU + repo)
8) [ ] [#30](https://github.com/haukened/rr-dns/issues/30) Bloom filters (exact+suffix) with sizing from N and DNS_BLOCKLIST_BLOOM_FP
	- [ ] Function to compute m,k from N,p; serialization not required in v0.3
	- [ ] Tests: FP rate sanity within tolerance; negative fast path
9) [ ] [#31](https://github.com/haukened/rr-dns/issues/31) Bolt backend: buckets `exact`/`suffix`/`meta` (versioned), reversed-domain keys, prefix scans
	- [ ] Create/open DB; RO transactions for queries
	- [ ] Exact bucket by canonical domain; suffix bucket by reversed-domain keys
	- [ ] Prefix scan via cursor; tests for lookups and scans
10) [ ] [#32](https://github.com/haukened/rr-dns/issues/32) Bolt backend: atomic update (versioned buckets or temp-file rename with reopen)
	- [ ] RCU-style swap without disrupting readers; active version marker
	- [ ] Tests: swap under concurrent reads
11) [ ] [#33](https://github.com/haukened/rr-dns/issues/33) Decision LRU cache with metrics (hits/misses/evictions)
	- [ ] Size configurable; concurrency-safe; expose counters
	- [ ] Tests: hit/miss/evict behavior
12) [ ] [#34](https://github.com/haukened/rr-dns/issues/34) Blocklist repository: IsBlocked/Update/Stats (replace blocklist/nop.go)
	- [ ] Query path: LRU → Bloom → Bolt (exact/suffix iteration)
	- [ ] Update path: build, write, swap, refresh Bloom, clear LRU
	- [ ] Stats: totals, last update time, counters; unit tests

Parent 3: [#20](https://github.com/haukened/rr-dns/issues/20) Ingestion and Updates
13) [ ] [#35](https://github.com/haukened/rr-dns/issues/35) File loader (read configured local files)
	- [ ] Supports multiple files; merge+dedupe; reports per-source counts/errors
	- [ ] Tests: truncation/append changes detected on next refresh
14) [ ] [#36](https://github.com/haukened/rr-dns/issues/36) HTTP(S) fetcher (ETag/Last-Modified optional, timeouts/backoff, max size)
	- [ ] Conditional GET; sane timeouts; retry with backoff; max body size
	- [ ] Tests: 200/304 paths, timeouts, retry, size limit
15) [ ] [#37](https://github.com/haukened/rr-dns/issues/37) Updater scheduler: periodic refresh (uses clock); SIGHUP-triggered refresh
	- [ ] Uses MockClock for tests; failure retains previous version; metrics
	- [ ] Tests: interval ticks, SIGHUP immediate refresh, error retry

Parent 4: [#21](https://github.com/haukened/rr-dns/issues/21) Wire + Resolver Integration (modes)
16) [ ] [#38](https://github.com/haukened/rr-dns/issues/38) Wire: EDNS(0) Extended DNS Error support in codec
	- [ ] OPT RR encoding/decoding; correct EDE code/reason for policy block
	- [ ] Tests: presence/absence based on client EDNS support
17) [ ] [#39](https://github.com/haukened/rr-dns/issues/39) Resolver: integrate non-authoritative path
	- [ ] Consult repo only when no authoritative zone answer; preserve AA rules
	- [ ] Tests: authoritative zones unaffected by blocklist
18) [ ] [#40](https://github.com/haukened/rr-dns/issues/40) Resolver mode: REFUSED with EDE (default)
	- [ ] RCODE=REFUSED; include EDE; non-cacheable; logging consistent
	- [ ] Tests: behavior and headers
19) [ ] [#41](https://github.com/haukened/rr-dns/issues/41) Resolver mode: NXDOMAIN with short negative TTL and cache interaction
	- [ ] Minimal response; configurable short negative TTL; cache interplay noted
	- [ ] Tests: TTL honored; caching not excessive
20) [ ] [#42](https://github.com/haukened/rr-dns/issues/42) Resolver mode: Sinkhole A/AAAA with configurable TTL
	- [ ] A/AAAA synthesized from config; TTL applied; no AA flag
	- [ ] Tests: A-only, AAAA-only, both; TTL

Parent 5: [#22](https://github.com/haukened/rr-dns/issues/22) Quality (tests, docs, benchmarks)
21) [ ] [#43](https://github.com/haukened/rr-dns/issues/43) Tests: parsers; matching (exact/suffix; unicode; dots; case); Bloom FP sanity; Bolt prefix scans/version swap; LRU behavior; scheduler (MockClock); resolver mode matrix
	- [ ] CI green; coverage for new packages; flaky tests eliminated
22) [ ] [#44](https://github.com/haukened/rr-dns/issues/44) Documentation: README (features, env table, compose example); arc42 (runtime, repos, gateways; policy and modes); size/memory notes
	- [ ] README env table includes DNS_BLOCKLIST_* and sinkhole settings
	- [ ] arc42 updated with storage design, wildcard semantics, modes
23) [ ] [#45](https://github.com/haukened/rr-dns/issues/45) Benchmarks: IsBlocked p50/p95 (cold/warm), update time for large lists; memory/disk sizing notes
	- [ ] go test -bench for matcher; dataset generator; record baseline numbers

## Wildcard and suffix semantics

Supported inputs (normalized):
- Leading-star wildcard: "*.example.com" → treated as suffix rule with root "example.com"
- Leading-dot shorthand: ".example.com" → same as above
- Plain domain: "example.com" → treated as a suffix rule that matches the apex and all subdomains

Not supported in v0.3:
- Mid-label wildcards (e.g., "foo.*.example.com")
- Trailing/star globs (e.g., "example.*", "*example.com")
- Adblock-style expressions (e.g., "||example.com^")

Parsing and normalization:
- Strip a single leading "*." or "."; lowercase; remove trailing dot; optional IDNA to ASCII (punycode)
- De-duplicate rules after normalization

Matching semantics:
- Suffix rules match the apex label and any subdomain (i.e., apex-inclusive). Use exact rules only when you want apex-only blocking
- Implementation uses reversed-domain keys (e.g., suffix root "example.com" stored as "com.example.")
- For a query, generate candidate suffixes, check BloomSuffix first, then Bolt for an exact key match per candidate

Additional tasks
- [ ] R1: Parser: accept leading "*."/"." forms and map to suffix kind
- [ ] T1: Tests: apex inclusion behavior ("example.com" blocks both apex and "a.example.com")

## Operational notes
- Failure modes
  - If Bolt DB missing/corrupt: start with empty active version; log error and continue
  - If update fails: retain previous active version and Bloom filters; retry next interval
- Metrics (log counters; later: expvar/prom)
  - bloom_exact_checks, bloom_suffix_checks, bloom_fp_estimate
  - bolt_exact_lookups, bolt_suffix_lookups, bolt_prefix_scans
  - lru_hits, lru_misses, lru_evictions
  - update_success, update_fail, rules_total_exact, rules_total_suffix

## Gaps and decisions to finalize
- Normalization
	- IDNA/punycode: ensure we normalize via existing utils (reuse `internal/dns/common/utils` canonicalization)
	- Unicode dots and whitespace variants (e.g., U+3002) mapped to '.'
	- Public suffix guard: optionally reject rules at pure TLD/public-suffix unless `DNS_BLOCKLIST_ALLOW_PUBLIC_SUFFIX=true` (defer or document)
- Resolver response semantics
	- For NXDOMAIN policy, construct minimal response without authority section (we're not authoritative)
	- Define cache TTL for policy NXDOMAIN/REFUSED; interact with existing cache (disable or short TTL?)
	- Document policy trade-offs and allow switching to REFUSED
- Updater behavior
	- Support manual refresh via SIGHUP or admin endpoint (v0.3: SIGHUP)
	- HTTP client: timeouts, retries with backoff, max size per feed
	- Safe temp files/atomic rename on the same filesystem; handle permissions in Docker
- Observability
	- Structured logs with source and version; sampling to avoid sensitive domain logs at info
	- Optional debug endpoint (later); for now, add a tiny CLI `rr-dnsd blocklist inspect` (defer if scope tight)
- Performance
	- Benchmarks: IsBlocked p50/p95 with varying N; cold vs warm LRU; update time for 1M rules
	- Size guidance: memory for Bloom+LRU and on-disk Bolt size per 1M entries

Additional tasks
- [ ] N1: Normalization: IDNA/punycode and Unicode dot mapping; reuse existing utils
- [ ] N2: Optional public-suffix guard and validation
- [ ] P1: Define/implement response construction for NXDOMAIN/REFUSED and cache TTL interaction
- [ ] U1: SIGHUP-triggered refresh; HTTP client with sane timeouts/backoff and max body size
- [ ] O1: Structured logs with rule source/version and sampling
- [ ] B1: Benchmarks for matcher and updater; include basic size/memory notes in README

## Milestones
- M1 Core (local files)
	- Issues #23–#35, #38–#40, subset of #43–#44 (local-only)
- M2 Remote feeds + updates
	- Issues #36–#37, #41–#42, expand #43–#44
- M3 Polish
	- Finalize #44–#45, metrics polish, edge-case parsers, docs/arc42 refinements

## Acceptance criteria
- With DNS_BLOCKLIST_ENABLED=true and local file of domains, resolver returns REFUSED by default for blocked names and subdomains, without affecting authoritative zones (NXDOMAIN and sinkhole modes behave as configured)
- Multiple sources (files/URLs) merge without duplicates; updates reflect changed lists within one interval
- Tests cover parsers, matching, and integration; CI green

## Open questions
- Should plain "example.com" block only that label or all subdomains by default? (proposal: both exact and suffix; document behavior)
- How large are typical lists and required memory footprint? (measure; optimize if needed)
- Conditional GET (ETag/If-Modified-Since) in v0.3 or later?

